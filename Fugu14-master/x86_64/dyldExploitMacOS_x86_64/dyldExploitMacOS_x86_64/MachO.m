//
//  MachO.m
//  iDebug
//
//  Created by Linus Henze.
//  Copyright Â© 2020/2021 Linus Henze. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <mach-o/loader.h>
#import <mach-o/nlist.h>
#import <mach-o/fat.h>

#import "MachO.h"

#if defined(__x86_64__)
    #define THIS_ARCH_CPUTYPE CPU_TYPE_X86_64
#elif defined(__arm64__) || defined(__aarch64__)
    #define THIS_ARCH_CPUTYPE CPU_TYPE_ARM64
#else
    #error "Please add a case for your architecture"
#endif

struct load_command *findLoadCommandOfType(uint8_t *image, struct load_command *begin, uint32_t type) {
    struct mach_header_64 *header = (struct mach_header_64*) image;
    if (header->magic != MH_MAGIC_64) {
        return NULL; //That's not a mach-o image
    }
    
    struct load_command *startCmd = (struct load_command*) (image + sizeof(struct mach_header_64));
    
    struct load_command *ldCmd = begin;
    if (ldCmd == NULL) {
        ldCmd = startCmd;
    } else {
        ldCmd = (struct load_command*) ((uintptr_t) ldCmd + ldCmd->cmdsize);
    }
    
    uintptr_t endAddr = (uintptr_t) startCmd + header->sizeofcmds;
    
    while ((uintptr_t) ldCmd < endAddr) {
        if (ldCmd->cmd == type) {
            return ldCmd;
        }
        ldCmd = (struct load_command*) ((uintptr_t) ldCmd + ldCmd->cmdsize);
    }
    
    return NULL;
}

struct segment_command_64 *findSegmentLoadCommand(uint8_t *image, char *segment) {
    struct load_command *ldCmd = findLoadCommandOfType(image, NULL, LC_SEGMENT_64);
    
    while (ldCmd != NULL) {
        struct segment_command_64 *sLdCmd = (struct segment_command_64*) ldCmd;
        if (strcmp(sLdCmd->segname, segment) == 0) {
            return (struct segment_command_64*) ldCmd;
        } else {
            ldCmd = findLoadCommandOfType(image, ldCmd, LC_SEGMENT_64);
        }
    }
    
    return NULL;
}

struct section_64 *findSectionFromSegment(struct segment_command_64 *segment, char *section) {
    struct section_64 *sect = (struct section_64 *) ((uintptr_t) segment + sizeof(struct segment_command_64));
    for (size_t i = 0; i < segment->nsects; i++) {
        if (strcmp(sect->sectname, section) == 0) {
            return sect;
        }
        
        sect++;
    }
    
    return NULL;
}

@implementation MachO

+ (instancetype) createWithFile: (NSString*) file {
    return [[MachO alloc] initWithFile:file];
}

- (instancetype) initWithFile: (NSString*) file {
    self = [super init];
    
    self.data = [NSData dataWithContentsOfFile: file];
    if (self.data == NULL) {
        return NULL;
    }
    
    struct fat_header *header = (struct fat_header *) [self.data bytes];
    if (OSSwapBigToHostInt32(header->magic) == FAT_MAGIC) {
        struct fat_arch *arch = (struct fat_arch*) ((uintptr_t) header + sizeof(header));
        for (size_t i = 0; i < OSSwapBigToHostInt32(header->nfat_arch); i++) {
            if (OSSwapBigToHostInt32(arch[i].cputype) == THIS_ARCH_CPUTYPE) {
                uint32_t offset = OSSwapBigToHostInt32(arch[i].offset);
                uint32_t size = OSSwapBigToHostInt32(arch[i].size);
                
                self.data = [self.data subdataWithRange: NSMakeRange(offset, size)];
                
                return self;
            }
        }
        
        return NULL;
    } else if (OSSwapBigToHostInt32(header->magic) == FAT_MAGIC_64) {
        // UNTESTED
        
        struct fat_arch_64 *arch = (struct fat_arch_64*) ((uintptr_t) header + sizeof(header));
        for (size_t i = 0; i < OSSwapBigToHostInt32(header->nfat_arch); i++) {
            if (OSSwapBigToHostInt32(arch[i].cputype) == THIS_ARCH_CPUTYPE) {
                uint64_t offset = OSSwapBigToHostInt64(arch[i].offset);
                uint64_t size = OSSwapBigToHostInt64(arch[i].size);
                
                self.data = [self.data subdataWithRange: NSMakeRange(offset, size)];
                
                return self;
            }
        }
        
        return NULL;
    }
    
    return self;
}

- (uint64_t) offsetOfGotEntry: (NSString*) name {
    uint8_t *image = (uint8_t*) [self.data bytes];
    
    // First we need to find either __auth_got (PAC) or __la_symbol_ptr
    struct segment_command_64 *data_const = findSegmentLoadCommand(image, "__DATA_CONST");
    if (!data_const) {
        return 0;
    }
    
    struct section_64 *got = findSectionFromSegment(data_const, "__auth_got");
    if (!got) {
        // No PAC
        data_const = findSegmentLoadCommand(image, "__DATA");
        got = findSectionFromSegment(data_const, "__la_symbol_ptr");
        if (!got) {
            return 0;
        }
    }
    
    // Now check the flags
    if (got->flags != S_NON_LAZY_SYMBOL_POINTERS && got->flags != S_LAZY_SYMBOL_POINTERS) {
        return 0;
    }
    
    uint64_t gotStart = got->addr - 0x100000000;
    size_t numOfSymbols = got->size / 8;
    
    // Find string table
    struct symtab_command *symtabCmd = (struct symtab_command*) findLoadCommandOfType(image, NULL, LC_SYMTAB);
    if (!symtabCmd) {
        return 0;
    }
    
    char *strTable = (char*) ((uintptr_t) image + symtabCmd->stroff);
    
    // Find symtab
    struct nlist_64 *symtab = (struct nlist_64*) ((uintptr_t) image + symtabCmd->symoff);
    
    // Find dsymtab
    struct dysymtab_command *dsymtabCmd = (struct dysymtab_command*) findLoadCommandOfType(image, NULL, LC_DYSYMTAB);
    if (!dsymtabCmd) {
        return 0;
    }
    
    uint32_t *dsymtab = (uint32_t*) ((uintptr_t) image + dsymtabCmd->indirectsymoff);
    dsymtab += got->reserved1;
    
    // Iterate over dsymtab
    for (size_t i = 0; i < numOfSymbols; i++) {
        if (strcmp(&strTable[symtab[*dsymtab].n_un.n_strx], [name UTF8String]) == 0) {
            return gotStart;
        }
        
        dsymtab++;
        gotStart += 8;
    }
    
    return 0;
}

- (uint64_t) locationOfBytes: (const char*) bytes length: (size_t) len {
    uint8_t *image = (uint8_t*) [self.data bytes];
    
    // Find __TEXT.__text
    struct segment_command_64 *text = findSegmentLoadCommand(image, "__TEXT");
    if (!text) {
        return 0;
    }
    
    struct section_64 *text_text = findSectionFromSegment(text, "__text");
    if (!text_text) {
        return 0;
    }
    
    char *start = (char*) ((uintptr_t) image + text->fileoff + text_text->offset);
    char *found = memmem(start, text_text->size, bytes, len);
    if (!found) {
        return 0;
    }
    
    return (uint64_t) ((uintptr_t) found - (uintptr_t) image);
}

- (uint64_t) getTextSlide {
    uint8_t *image = (uint8_t*) [self.data bytes];
    
    // Find __TEXT
    struct segment_command_64 *text = findSegmentLoadCommand(image, "__TEXT");
    if (!text) {
        return 0;
    }
    
    return text->vmaddr;
}

@end
